// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model User {
    id             String      @id @default(cuid())
    username       String   @unique
    studentNumber  String   @unique
    password       String
    firstName      String?
    lastName       String?
    email          String?
    dateJoined     DateTime @default(now())
    major          String?
    isActive       Boolean  @default(true)
    isStaff        Boolean  @default(false)
    lastLogin      DateTime @default(now())
    schedules      Schedule[]
    sessions       Session[]
    accounts       Account[]
}

model Department {
    name         String
    code         String      @id
    professors   Professor[]
    courses      Course[]
}

model Professor {
    id                   Int         @id @default(autoincrement())
    fullName             String
    departmentId         String
    department           Department  @relation(fields: [departmentId], references: [code])
    courses              Course[]
}

model Course {
    id                   Int         @id @default(autoincrement())
    courseName           String
    courseCode           String
    unitCount            Int
    presentedById        Int
    group                Int
    locationId           Int?
    finalExamDate        String?
    finalExamTime        DateTime?
    numberOfPetitioners  Int
    numberOfCapacity     Int
    numberOfEnrolled     Int
    departmentId         String?
    info                 String?
    warning              String
    grade                String
    presentedBy          Professor   @relation(fields: [presentedById], references: [id])
    department           Department? @relation(fields: [departmentId], references: [code])
    daysOfWeek           Int[]
    startTime            String?
    endTime              String?
    schedules            Schedule[]  @relation("ScheduleToCourse")

    @@unique([courseCode, group])
}

model Schedule {
    id          Int          @id @default(autoincrement())
    userId      String
    status      String
    user        User         @relation(fields: [userId], references: [id])
    courses     Course[]     @relation("ScheduleToCourse")
}
